






using namespace std;









// ---------------Trigonometry----------------------
	float angDiff(float a1, float a2) {
		float a = a1-a2;
		a = fmod((a + M_PI), (2 * M_PI)) - M_PI;
		return wraparound(a);
	}

	float wraparound(float th) { // [-pi, pi]
		if (th > M_PI)
			th -= 2 * M_PI;
		if (th < -M_PI)
			th += 2 * M_PI;
		return th;
	}
	float vectorNorm(Pose p) {
		std::vector<float> v { p.x, p.y };
		float res = inner_product(v.begin(), v.end(), v.begin(), 0.0f);
		return sqrt(res);
	}
	float vectorNorm(Speed p) {
		return sqrt(magSquared(p));
	}
	float magSquared(Speed p) {
		std::vector<float> v { p.v, p.w };
		float res = inner_product(v.begin(), v.end(), v.begin(), 0.0f);
		return res;
	}
float sqrt_approx(float z) {
	int val_int = *(int*) &z; /* Same bits, but as an int */
	/*
	 * To justify the following code, prove that
	 *
	 * ((((val_int / 2^m) - b) / 2) + b) * 2^m = ((val_int - 2^m) / 2) + ((b + 1) / 2) * 2^m)
	 *
	 * where
	 *
	 * b = exponent bias
	 * m = number of mantissa bits
	 *
	 * .
	 */

	val_int -= 1 << 23; /* Subtract 2^m. */
	val_int >>= 1; /* Divide by 2. */
	val_int += 1 << 29; /* Add ((b + 1) / 2) * 2^m. */

	return *(float*) &val_int; /* Interpret again as float */
}

// inverse of normalise speed.
	Speed getRealSpeed(Speed speed_old) {
		Speed speed = Speed(speed_old);
		if (speed.v >= 0) {
			speed.v *= ( MAX_LIN_VEL);
		} else {
			speed.v *= ( MIN_LIN_VEL);
		}
		if (speed.w >= 0) {
			speed.w *= ( MAX_ANG_VEL);
		} else {
			speed.w *= ( MIN_ANG_VEL);
		}
		return speed;
	}

	Speed normaliseSpeed(Speed speed_old) {
		Speed speed = Speed(speed_old);
		if (speed.v >= 0) {
			speed.v /= ( MAX_LIN_VEL);
		} else {
			speed.v /= ( MIN_LIN_VEL);
		}
		if (speed.w >= 0) {
			speed.w /= ( MAX_ANG_VEL);
		} else {
			speed.w /= ( MIN_ANG_VEL);
		}
		return speed;
	}

// Assumes pose is to be rotated to a coordinate system with T as origin coordinate.
void rotateFromBody(RealPoint &pose, Pose T) {
	float x = pose.x;
	float y = pose.y;

	pose.x = cos(T.th) * x - sin(T.th) * y;
	pose.y = sin(T.th) * x + cos(T.th) * y;

	pose.x += T.x;
	pose.y += T.y;
}

//Assumes lower to upper forms a continuous region.
int getQuadrant(float upper) {

	upper = wraparound(upper);

	if ((upper >= 0) && (upper < M_PI / 2)) {
		return 0;
	}

	if ((upper >= M_PI / 2) && (upper < M_PI)) {
		return 1;
	}
	if ((upper >= -M_PI) && (upper < -M_PI / 2)) {
		return 2;
	}
	if ((upper >= -M_PI / 2) && (upper < 0)) {
		return 3;
	}
}
bool compareQuadrant(float ang, float upper, float lower) {
	// Find quadrant of region.
	// Check first quadrant
	// int code means 4321 bits regions for quadrants.
	int8_t codeR = 0;
	int8_t code = 0;
	int8_t qstart = getQuadrant(lower);
	int8_t qend = getQuadrant(upper);
	qend++;
	if (qend == 4) {
		qend = 0;
	}
	int8_t q = getQuadrant(ang);
	bool in = false;
	int8_t i = qstart;
	while (i != qend) {
		if (i == 4) {
			i = 0;
		}
		if (q == i) {
			in = true;
			break;
		}
		i++;
	}

	return in;

}
